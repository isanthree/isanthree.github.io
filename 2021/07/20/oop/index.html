<!DOCTYPE html><html lang="zh-cmn-Hans" prefix="og: http://ogp.me/ns#" class="han-init"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" /><title>面向对象编程学习整理 &mdash; focus_on_one_thing</title><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/vendor/primer-css/css/primer.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/css/components/collection.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/css/components/repo-card.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/css/sections/repo-list.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/css/components/boxed-group.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/css/globals/common.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/css/globals/responsive.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/css/posts/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/vendor/octicons/octicons/octicons.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/mzlogin/rouge-themes@master/dist/thankful_eyes.css"><link rel="canonical" href="https://isanthree.github.io/2021/07/20/oop/"><link rel="alternate" type="application/atom+xml" title="focus_on_one_thing" href="https://isanthree.github.io/feed.xml"><link rel="shortcut icon" href="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/favicon.ico"><meta property="og:title" content="面向对象编程学习整理"><meta name="keywords" content="oop"><meta name="og:keywords" content="oop"><meta name="description" content="面向对象编程"><meta name="og:description" content="面向对象编程"><meta property="og:url" content="https://isanthree.github.io/2021/07/20/oop/"><meta property="og:site_name" content="focus_on_one_thing"><meta property="og:type" content="article"><meta property="og:locale" content="zh_CN" /><meta property="article:published_time" content="2021-07-20"> <script src="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/vendor/jquery/dist/jquery.min.js"></script> <script src="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/js/jquery-ui.js"></script> <script src="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/js/main.js"></script> <script data-ad-client="ca-pub-7093222719567591" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script></head><body class="" data-mz=""><header class="site-header"><div class="container"><h1><a href="https://isanthree.github.io/" title="focus_on_one_thing"><span class="octicon octicon-mark-github"></span> focus_on_one_thing</a></h1><button class="collapsed mobile-visible" type="button" onclick="toggleMenu();"> <span class="icon-bar"></span> <span class="icon-bar"></span> <span class="icon-bar"></span> </button><nav class="site-header-nav" role="navigation"> <a href="https://isanthree.github.io/" class=" site-header-nav-item" target="" title="首页">首页</a> <a href="https://isanthree.github.io/categories/" class=" site-header-nav-item" target="" title="分类">分类</a> <a href="https://isanthree.github.io/archives/" class=" site-header-nav-item" target="" title="归档">归档</a> <a href="https://isanthree.github.io/wiki/" class=" site-header-nav-item" target="" title="维基">维基</a> <a href="https://isanthree.github.io/links/" class=" site-header-nav-item" target="" title="链接">链接</a> <a href="https://isanthree.github.io/about/" class=" site-header-nav-item" target="" title="关于">关于</a></nav></div></header><section class="collection-head small geopattern" data-pattern-id="面向对象编程学习整理"><div class="container"><div class="columns"><div class="column three-fourths"><div class="collection-title"><h1 class="collection-header">面向对象编程学习整理</h1><div class="collection-info"> <span class="meta-info"> <span class="octicon octicon-calendar"></span> 2021/07/20 </span> <span class="meta-info"> <span class="octicon octicon-file-directory"></span> <a href="https://isanthree.github.io/categories/#OOP" title="OOP">OOP</a> </span> <span class="meta-info"> <span class="octicon octicon-clock"></span> 共 9036 字，约 26 分钟 </span></div></div></div><div class="column one-fourth mobile-hidden"><div class="collection-title"> <img style="height:72px;width:72px" src="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/images/qrcode_isanthree_github_io.jpg" alt="程序员" /></div></div></div></div></section><section class="container content"><div class="columns"><div class="column three-fourths" ><article class="article-content markdown-body"><h1 id="面向对象编程">面向对象编程</h1><h2 id="内联函数inline">内联函数（inline）</h2><p>inline：在类内定义的函数，都默认为内联函数，类外的函数，则需要在返回类型前添加inline。</p><p>inline只是建议编译构建函数时，构建为内联的，具体是不是则由编译决定。</p><p>inline作用：空间换时间，加快程序的运行速度。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">class</span> <span class="nc">Complex</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">Complex</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="p">);</span> <span class="c1">// 操作符重载</span>
  <span class="p">......</span>
<span class="p">};</span>

<span class="kr">inline</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="n">Complex</span><span class="o">::</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">__doapl</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="构造函数constructor">构造函数（constructor）</h2><p>一般使用初始化列表（initialization list）来初始化参数。</p><p>没有在初始化列表中的成员参数会被隐式初始化</p><p>构造函数一般是声明为public，供他人创建，也有声明为 private 的，例如下面的单例模式：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span><span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">static</span> <span class="n">A</span><span class="o">&amp;</span> <span class="n">getInstance</span><span class="p">(){</span><span class="c1">//调用函数时，才创建对象</span>
		<span class="k">static</span> <span class="n">A</span> <span class="n">a</span><span class="p">;</span> 
		<span class="k">return</span> <span class="n">a</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">private:</span>
	<span class="n">A</span><span class="p">(){}</span>
<span class="p">};</span>
</code></pre></div></div><p>在单例模式中，外部无法显式调用构造函数，没有构造函数则无法创建对象，因此将 getInstance() 声明为静态的，可通过类来直接调用。</p><h2 id="参数的值传递和引用传递">参数的值传递和引用传递</h2><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">getReal</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// const：只读，不能修改对象的数据</span>
<span class="kt">int</span> <span class="n">getImag</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="n">Complex</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="p">);</span>

<span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 在全局定义</span>
    <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="sc">'('</span> <span class="o">&lt;&lt;</span> <span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span> <span class="o">&lt;&lt;</span> <span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">')'</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><blockquote><p>一般来说，引用传递效率快于值传递，为了提高效率，我们优先使用引用传递参数，避免了参数的复制。若不希望在函数体内对输入参数进行修改，应使用<code class="language-plaintext highlighter-rouge">const</code>修饰输入参数。若函数的返回值是临时变量，则只能通过值传递返回。</p></blockquote><p>什么是值传递，什么是引用传递？</p><p>举个比喻性例子：现在有一个包裹，并且需要把它传递出去。</p><ul><li>值传递：把包裹里面的东西全部拷贝到一个临时包裹，整个传过去，无论多大都一起传过去</li><li>引用传递：把包裹的地址传过去，告诉对方包裹在哪里。这里知道了地址，就知道了包裹有什么东西</li></ul><p>区别：</p><ol><li><p>对于大包裹来说，值传递的速度慢，但是引用传递则没有影响，因为只是传了一个地址值，因此引用传递的速度一般快于值传递</p></li><li><p>（传递的包裹或地址，都是对方的需要用到的一个参数）</p><p>值传递：当对参数进行修改时，不影响原包裹</p><p>引用传递：当对参数进行修改时，影响原包裹</p></li></ol><ul><li>const：只读 引用传递比值传递快，当我只是想要传递速度快，而不想对方因为修改（编译报错）而影响我原来的包裹时，只需加入 const 关键字</li></ul><p>==PS：参数传递首先考虑引用。==</p><p><strong>● 问题：什么时候不能使用引用传递？</strong></p><p>某些局部变量。比如在某函数创建的局部变量，要将该变量传递出去，只能用值传递。因为当所在函数生命周期结束（执行完毕）后，该变量已经不存在，无法将其地址再传给别人。</p><h2 id="友元">友元</h2><p>友元函数不受访问级别的控制，可以自由访问对象的所有成员。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">friend</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="n">__doapl</span><span class="p">(</span><span class="n">Complex</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="p">);</span>
</code></pre></div></div><p>friend 赋予其他函数或者类访问类内部<code class="language-plaintext highlighter-rouge">protected</code>或者<code class="language-plaintext highlighter-rouge">private</code>成员的访问权限，打破了类的封装。</p><p>看一个类的成员函数：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Complex</span> <span class="p">{</span>
  <span class="nl">public:</span>
	<span class="p">......</span>
    <span class="kt">int</span> <span class="n">func</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
    	<span class="k">return</span> <span class="n">param</span><span class="p">.</span><span class="n">re</span> <span class="o">+</span> <span class="n">param</span><span class="p">.</span><span class="n">im</span><span class="p">;</span>
	<span class="p">}</span>

  <span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">;</span>
    <span class="p">......</span>
<span class="p">};</span>
</code></pre></div></div><p>是不是觉得很奇怪，在类当中，私有的属性，只能由类自己的成员函数去获取，而无法被外界所获取。</p><p>比如，下面的代码：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Complex</span> <span class="nf">complex</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">complex</span><span class="p">.</span><span class="n">re</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">complex</span><span class="p">.</span><span class="n">im</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="c1">// 私有属性对 complex 对象不可见，编译错误</span>
</code></pre></div></div><p>那为什么外界传进来的对象 param 可以去访问 Complex 类的私有属性 re 和 im 呢？</p><p>原因在于：友元会打破类的封装性。==<strong>相同类的各个 objects 互为 friends</strong>==，在类里面定义一个方法，方法的形参是同类的别的对象，则可以直接获取该对象的私有属性。</p><h2 id="操作符重载">操作符重载</h2><p>1、代码片段一：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">complex</span><span class="p">.</span><span class="n">h</span><span class="o">:</span>
<span class="n">Complex</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="p">);</span> <span class="c1">// 操作符重载</span>

<span class="n">complex</span><span class="o">-</span><span class="n">demo</span><span class="p">.</span><span class="n">cpp</span><span class="o">:</span>
<span class="n">c2</span> <span class="o">+=</span> <span class="n">c1</span><span class="p">;</span>
</code></pre></div></div><p>如上，编译器怎么看待 <code class="language-plaintext highlighter-rouge">c2 += c1;</code> 的 <code class="language-plaintext highlighter-rouge">+=</code>符号，<code class="language-plaintext highlighter-rouge">+=</code>是作用在左边（c2）身上的，要是左边的东西要是对 <code class="language-plaintext highlighter-rouge">+=</code>有定义的话，编译器就找到了。</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="n">__doapl</span><span class="p">(</span><span class="n">Complex</span> <span class="o">*</span><span class="n">ths</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ths</span><span class="o">-&gt;</span><span class="n">re</span> <span class="o">+=</span> <span class="n">r</span><span class="p">.</span><span class="n">re</span><span class="p">;</span>
    <span class="n">ths</span><span class="o">-&gt;</span><span class="n">im</span> <span class="o">+=</span> <span class="n">r</span><span class="p">.</span><span class="n">im</span><span class="p">;</span>

    <span class="k">return</span> <span class="o">*</span><span class="n">ths</span><span class="p">;</span>
<span class="p">}</span>

<span class="kr">inline</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="n">Complex</span><span class="o">::</span><span class="k">operator</span><span class="o">+=</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">__doapl</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">r</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">c2</span> <span class="o">+=</span> <span class="n">c1</span><span class="p">;</span>
</code></pre></div></div><p>结合引用来看待以上三个代码片段：<code class="language-plaintext highlighter-rouge">__doapl()、operator+=()、c2 += c1;语句</code></p><p>为什么 __doapl() 方法中，定义的返回类型为 <code class="language-plaintext highlighter-rouge">Complex &amp;</code>，但是却返回 <code class="language-plaintext highlighter-rouge">*ths</code>。因为==传递者是不需要知道接收者是以引用形式接收的==，这就是使用引用的好处。</p><p>看一下 c2 += c1; 语句，首先 c1 是传递者，它要传递到 operator+=(const Complex &amp;r) 中，operator+=() 参数列表中的参数是接收者，由于==传递者是不需要知道接收者是以引用形式接收的==，因此 c1 可以直接传过去；进入函数体内，接下来会进入 <code class="language-plaintext highlighter-rouge">__doapl() 函数</code>体内；在 <code class="language-plaintext highlighter-rouge">__doapl() 函数</code>中，执行的返回值为 <code class="language-plaintext highlighter-rouge">*ths</code>，但是定义的返回类型为 Complex &amp;，这是因为在<code class="language-plaintext highlighter-rouge">__doapl() 函数</code>这里，<code class="language-plaintext highlighter-rouge">*ths</code>是传递者，将要接收 <code class="language-plaintext highlighter-rouge">*ths</code>的接收者的类型这里定义为 Complex &amp;，由于==传递者是不需要知道接收者是以引用形式接收的==，因此可以 <code class="language-plaintext highlighter-rouge">return *ths</code>。</p><p>2、代码片段二：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="n">Complex</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span> <span class="k">const</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="n">y</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">real</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">imag</span><span class="p">(</span><span class="n">y</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div><p>前面说过，引用传递在「将要被传递的变量是局部的」这种情况下必须使用值传递。假如要用引用传递，我们看一下代码，<code class="language-plaintext highlighter-rouge">real(x) + real(y)</code>运算后，存放结果的对象在哪里，必然需要在函数内部创建一个对象来存储，这个对象在函数生命周期结束时就会立即释放，传递出去的引用将是无效的，因此定义的返回类型为 <code class="language-plaintext highlighter-rouge">Complex</code>，而不是引用 <code class="language-plaintext highlighter-rouge">Complex &amp;</code>。</p><p>3、代码片段三：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="n">Complex</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>

<span class="kr">inline</span> <span class="n">Complex</span> <span class="k">operator</span><span class="o">-</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">Complex</span><span class="p">(</span><span class="o">-</span><span class="n">real</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="o">-</span><span class="n">imag</span><span class="p">(</span><span class="n">x</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div><p>上面这个对「正负号」的重载函数是从标准库中摘抄下来的。也许有人会说，上面不是说==传递者不需要接收者是以引用形式接收的==吗？x 不是局部变量，优先考虑引用传递，那么正号重载函数为什么不使用引用呢？</p><p>答：也可以使用引用，而且速度更快，这里或许说明类即使是标准库，设计的程序性能也不一定是最好的。（有人说是为了正负号重载函数设计的对称美，舍弃了引用）改写如下：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">inline</span> <span class="k">const</span> <span class="n">Complex</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="k">const</span> <span class="n">Complex</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
</code></pre></div></div><p>另外，operator - () 只能使用值传递，因为创建的是临时对象。</p><h2 id="拷贝构造函数拷贝赋值函数和析构函数">拷贝构造函数、拷贝赋值函数和析构函数</h2><blockquote><p>这三个函数，在欧洲被称为 “Big Three”，三大件，三位一体。</p><p>对于不带有指针的类，这「三大件」可以使用编译器默认为我们生成的版本；但是编写带有指针的类时，我们就有必要定义这三个特殊函数。</p></blockquote><p>发现没有，上面举的关于类的例子，都是不带指针的，但是，在 C++ 中，指针是经常被使用的东西，我们知道，当类里面存在指针时，需要自己定义拷贝函数，有没有思考过：如果不自己定义实现而使用库的，会出现什么问题？</p><p>我们来看一下这个类：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">String</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="p">......</span>

  <span class="nl">private:</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">m_data</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div><p>==浅拷贝==：假设 String 类有 a 和 b 两个实例对象，a 的数据为 “Hello”，b 的数据为 “World”，即 a 中的 m_data 指针指向的内存块存着字符串 “Hello”，b 的 m_data 指针指向的则为 “World”，但是，”Hello” 和 “World” 都不是属于类里面的成员。当我们使用库提供的拷贝时，不妨假设 a = b; 即把 b 的数据拷贝给 a，此时 a 的 m_data 指针也指向 “World” 了，这样看似也是可以得到想要的值，a 的 m_data 指针和 b 的相同了，都指向了同一块内存空间。但是，此时问题出现了，存着 “Hello” 的那一块内存没有指针指着了，也就是说造成了内存泄漏，这就是一个大问题。另外还有一个问题，一块内存被两个指针指着，这是一件很危险的事，当 b 的指针修改了这块内存的值，a 将会受到影响，不可取。</p><p>==深拷贝==：而使用自己定义的拷贝函数的话，不改变 a 的 m_data 指针值，而是将 b 的数据 “World” 直接拷贝一份放到 a 的 m_data 指针指向的内存空间，解决类内存泄漏的问题。</p><p>深拷贝和浅拷贝是要说的重点，现在简要说一下这三个函数，直接 show you code，一目了然：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 拷贝构造</span>
<span class="kr">inline</span> <span class="n">String</span><span class="o">::</span><span class="n">String</span><span class="p">(</span><span class="k">const</span> <span class="n">String</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m_data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">m_data</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">m_data</span><span class="p">,</span> <span class="n">str</span><span class="p">.</span><span class="n">m_data</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 析构函数：在类的生命周期即将结束前执行，内存回收，释放掉动态申请的内存</span>
<span class="kr">inline</span> <span class="n">String</span><span class="o">::~</span><span class="n">String</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">m_data</span><span class="p">;</span> <span class="p">}</span>

<span class="c1">// 拷贝赋值</span>
<span class="kr">inline</span> <span class="n">String</span> <span class="o">&amp;</span><span class="n">String</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">String</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="cm">/**
     * 检测自我赋值 self assigment
     * 很重要，如果没有自我检视并返回，就会进入未知风险状态：
     * 先把自己的内存释放掉，然后再照着“自己的内存”申请相同的内存大小，可能引发未知错误
     */</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>

    <span class="k">delete</span><span class="p">[]</span> <span class="n">m_data</span><span class="p">;</span>                           <span class="c1">// 先释放自己原来的内存</span>
    <span class="n">m_data</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">m_data</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="c1">// 再重新申请一块大小相等内存</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">m_data</span><span class="p">,</span> <span class="n">str</span><span class="p">.</span><span class="n">m_data</span><span class="p">);</span>

    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><h2 id="栈堆内存分配">栈、堆、内存分配</h2><h3 id="内存分配">内存分配</h3><p>看一段代码：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Complex</span> <span class="o">*</span><span class="n">pc</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Complex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
</code></pre></div></div><p>这一行语句，在编译器看来做了什么？实际上，C++ 编译器执行这条语句，分为了三个步骤：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="n">mem</span> <span class="o">=</span> <span class="k">operator</span> <span class="nf">new</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Complex</span><span class="p">));</span>  <span class="c1">// 分配内存</span>
<span class="n">pc</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Complex</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">mem</span><span class="p">);</span>  <span class="c1">// 类型转换</span>
<span class="n">pc</span><span class="o">-&gt;</span><span class="n">Complex</span><span class="o">::</span><span class="n">Complex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>  <span class="c1">// 调用构造函数</span>
</code></pre></div></div><p>显然，首先获得一块内存，operator new 其内部调用的 malloc() 去动态申请一块内存，这里 C++ 已经给我们封装好了；然后对指针进行类型转化；最后通过转型后的指针去调用构造函数完成对象的初始化。</p><p>new 的示意图：</p><p><img src="https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720215936.png" alt="在这里插入图片描述" /></p><p>再来看一段代码：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Complex</span><span class="o">*</span> <span class="n">pc</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">Complex</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">......</span>
<span class="k">delete</span> <span class="n">pc</span><span class="p">;</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">delete pc;</code>这个语句在编译器看来，是怎么执行的呢？</p><p>这里再次 show you the code：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Complex</span><span class="o">::~</span><span class="n">Complex</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span> <span class="c1">// 析构函数</span>
<span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="n">pc</span><span class="p">);</span> <span class="c1">// 释放内存</span>
</code></pre></div></div><p>显然，可以看到，删除 pc 指针，将分为两步进行，第一步：调用析构函数，释放类的属性成员指针指向的内存；第二步，释放该指针动态实例化的类对象。</p><p>delete 的示意图：</p><p><img src="https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720215835.png" alt="" /></p><h4 id="demo-代码">demo 代码</h4><p>demo：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;cstdlib&gt;
#include &lt;iostream&gt;
</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">A</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"constructor:"</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="o">~</span><span class="n">A</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"destory:"</span> <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">void</span> <span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="o">*</span><span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"new"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"delete"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="o">*</span><span class="k">operator</span> <span class="k">new</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"new[]"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="k">operator</span> <span class="k">delete</span><span class="p">[](</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"delete[]"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">A</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">();</span>
    <span class="k">delete</span> <span class="p">(</span><span class="n">a</span><span class="p">);</span>

    <span class="n">A</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="k">new</span> <span class="n">A</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="k">delete</span><span class="p">[]</span> <span class="n">b</span><span class="p">;</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div><p>输出：</p><div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">new</span><span class="w">
</span><span class="err">constructor:</span><span class="mi">0</span><span class="err">xffa</span><span class="mi">998</span><span class="w">
</span><span class="err">destory:</span><span class="mi">0</span><span class="err">xffa</span><span class="mi">998</span><span class="w">
</span><span class="err">delete</span><span class="w">
</span><span class="err">new</span><span class="p">[]</span><span class="w">
</span><span class="err">constructor:</span><span class="mi">0</span><span class="err">xffa</span><span class="mi">99</span><span class="err">c</span><span class="w">
</span><span class="err">constructor:</span><span class="mi">0</span><span class="err">xffa</span><span class="mi">99</span><span class="err">d</span><span class="w">
</span><span class="err">constructor:</span><span class="mi">0</span><span class="err">xffa</span><span class="mi">99</span><span class="err">e</span><span class="w">
</span><span class="err">destory:</span><span class="mi">0</span><span class="err">xffa</span><span class="mi">99</span><span class="err">e</span><span class="w">
</span><span class="err">destory:</span><span class="mi">0</span><span class="err">xffa</span><span class="mi">99</span><span class="err">d</span><span class="w">
</span><span class="err">destory:</span><span class="mi">0</span><span class="err">xffa</span><span class="mi">99</span><span class="err">c</span><span class="w">
</span><span class="err">delete</span><span class="p">[]</span><span class="w">
</span></code></pre></div></div><h3 id="堆栈">堆、栈</h3><p>VC 中对象在<code class="language-plaintext highlighter-rouge">debug</code>模式和<code class="language-plaintext highlighter-rouge">release</code>模式下的内存分布如下图所示,变量在内存中所占字节数必须被补齐为16的倍数,红色代表<code class="language-plaintext highlighter-rouge">cookie</code>保存内存块的大小,其最低位的<code class="language-plaintext highlighter-rouge">1</code>和<code class="language-plaintext highlighter-rouge">0</code>分别表示内存是否被回收。</p><table><thead><tr><th style="text-align: center">Complex 对象</th><th style="text-align: center">String 对象</th></tr></thead><tbody><tr><td style="text-align: center"><img src="https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720221014.png" alt="在这里插入图片描述" /></td><td style="text-align: center"><img src="https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720221022.png" alt="在这里插入图片描述" /></td></tr></tbody></table><p>数组中的元素是连续的，数组头部 4 个字节记录了数组长度：</p><table><thead><tr><th style="text-align: center">Complex 对象</th><th style="text-align: center">String 对象</th></tr></thead><tbody><tr><td style="text-align: center"><img src="https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720221416.png" alt="在这里插入图片描述" /></td><td style="text-align: center"><img src="https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720221432.png" alt="在这里插入图片描述" /></td></tr></tbody></table><blockquote><p>学习关于对象或对象数组申请这一部分的堆栈，是为了更好地了解编译器的行为，从而帮助我们更好地理解 new 和 delete 和内存相关的操作。</p></blockquote><p>我们都知道，<code class="language-plaintext highlighter-rouge">new[]</code>和<code class="language-plaintext highlighter-rouge">delete[]</code>应该配对使用。为什么要这样做呢？不这样做的后果是什么？学习了内存，根据数组在内存中的状态，自然可以理解为什么这样做了:</p><p><code class="language-plaintext highlighter-rouge">delete</code>操作符仅会调用一次析构函数，而<code class="language-plaintext highlighter-rouge">delete[]</code>操作符依次对每个对象调用析构函数，对于<code class="language-plaintext highlighter-rouge">String</code>这样带有指针的类，若将<code class="language-plaintext highlighter-rouge">delete[]</code>误用为<code class="language-plaintext highlighter-rouge">delete</code>会引起内存泄漏，如下图所示，将造成剩下的两个 String 成员变量指针所指向内存的泄漏。</p><p>流程如下：</p><p><img src="https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720222250.png" alt="在这里插入图片描述" /></p><h2 id="static-成员">static 成员</h2><p>对于类来说，<code class="language-plaintext highlighter-rouge">non-static</code>成员变量每个对象均存在一份，<code class="language-plaintext highlighter-rouge">static</code>成员变量、<code class="language-plaintext highlighter-rouge">non-static</code>和<code class="language-plaintext highlighter-rouge">static</code>成员函数在内存中仅存在一份。其中<code class="language-plaintext highlighter-rouge">non-static</code>成员函数通过指定<code class="language-plaintext highlighter-rouge">this</code>指针获得函数的调用权，而<code class="language-plaintext highlighter-rouge">static</code>函数不需要<code class="language-plaintext highlighter-rouge">this</code>指针即可调用.</p><p><img src="https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720222646.png" alt="在这里插入图片描述" /></p><p><code class="language-plaintext highlighter-rouge">static</code>成员函数可以通过对象调用，也可以通过类名调用：</p><div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Account</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="kt">double</span> <span class="n">m_rate</span><span class="p">;</span>
    <span class="k">static</span> <span class="kt">void</span> <span class="n">set_rate</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">m_rate</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
<span class="kt">double</span> <span class="n">Account</span><span class="o">::</span><span class="n">m_rate</span> <span class="o">=</span> <span class="mf">8.0</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Account</span><span class="o">::</span><span class="n">set_rate</span><span class="p">(</span><span class="mf">5.0</span><span class="p">);</span>
    <span class="n">Account</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">a</span><span class="p">.</span><span class="n">set_rate</span><span class="p">(</span><span class="mf">7.0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div><p><code class="language-plaintext highlighter-rouge">static</code>成员变量需要在类声明体外进行初始化。</p><h1 id="类之间的关系">类之间的关系</h1><h2 id="复合composition">复合（composition）</h2><p>复合表示一种<code class="language-plaintext highlighter-rouge">has-a</code>的关系，即类的成员存在一个或多个别的类，STL 中<code class="language-plaintext highlighter-rouge">queue</code>的实现就使用了复合关系。这种结构也被称为「<strong>adapter 模式</strong>」。</p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210719220346.png" alt="在这里插入图片描述" /></p><p>复合关系下构造由内而外，析构由外而内：</p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210719220406.png" alt="在这里插入图片描述" /></p><h2 id="委托aggregation-composition-by-reference">委托（aggregation; composition by reference）</h2><p>pointer to implement(Handle/Body)</p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210719213139.png" alt="请添加图片描述" /></p><p>委托将类的定义与类的实现分隔开来，也被称为「编译防火墙」。</p><h2 id="继承extension">继承（extension）</h2><p>继承表示一种<code class="language-plaintext highlighter-rouge">is-a</code>的关系，STL 中<code class="language-plaintext highlighter-rouge">_List_node</code>的实现就使用了继承关系.</p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210719213140.png" alt="在这里插入图片描述" /></p><p>继承关系下，构造由内而外，析构由外而内：</p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210719213141.png" alt="img" /></p><blockquote><p>父类的析构函数必须是 virtual，否则会出现 undefine behavior</p></blockquote><h3 id="虚函数">虚函数</h3><p>成员函数有 3 种：非虚函数、虚函数和纯虚函数:</p><ul><li>非虚（non-virtual）函數：不希望子类重新定义（override，复写）的函数</li><li>虚（virtual）函數：子类可以重新定义（override，复写）的函数，且有默认定义</li><li>纯虚(pure virtual)函數：子类必须重新定义（override，复写）的函数，没有默认定义</li></ul><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210719184951.png" alt="在这里插入图片描述" /></p><p>虚函数的使用举例说明：「使用虚函数框架」，假设有一个人想要实现一个一般性的文件处理类，这个文件处理过程包括：打开文件、读取文件、关闭文件，现在的思路是，在这个文件处理类里面实现「打开文件」、「关闭文件」这两个操作，但是，「读取文件」操作留给用户定义，因为作者不知道用户要以什么样的方式（格式）去读取这个文件，此时，「读取文件」操作就可以用虚函数来写，不给出具体定义或实现，让用户（子类）去复写，这就是大体的框架。下面是代码流程示例：</p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210719214806.png" alt="在这里插入图片描述" /></p><p>如图，框架中父类<code class="language-plaintext highlighter-rouge">CDocument</code>的<code class="language-plaintext highlighter-rouge">Serialize()</code>函数设为虚函数，由框架使用者编写的子类<code class="language-plaintext highlighter-rouge">CMyDoc</code>定义具体的文件处理过程，代码如下：</p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210719215858.png" alt="在这里插入图片描述" /></p><p>虚函数是很实用的，因为很多时候，设计者设计的都只是一个框架，里面涉及了哪些功能，设计者都已经给我们想好了，这些都是固定的功能。但是，有另外一些功能是需要私人定制的，根据不同的需求有不同的实现，那么将这些功能函数声明为虚函数，由用户来定义实现，就显得很必要了。</p><h1 id="面向对象设计范例">面向对象设计范例</h1><h2 id="使用委托--继承实现-observer-模式">使用委托 + 继承实现 Observer 模式</h2><p>解决的问题：一个文件，四个窗口，当文件变化时，窗口也会跟着改变。</p><p>使用 Observer 模式实现多个窗口订阅同一份内容并保持实时更新：</p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210719222810.png" alt="在这里插入图片描述" /></p><p>类结构如下图：</p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210719222654.png" alt="" /></p><h2 id="使用委托继承实现-composite-模式">使用委托+继承实现 Composite 模式</h2><p>使用 Composite 模式实现多态，类结构图如下：</p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210719223406.png" alt="在这里插入图片描述" /></p><h2 id="使用委托继承实现-prototype-模式">使用委托+继承实现 Prototype 模式</h2><p>看一张图：</p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210719231025.png" alt="image-20210719231022071" /></p><p>上面的图一开始看的一头雾水，不急，先看比较贴近生活的东西。</p><p>相信大多数的人都看过《西游记》，对孙悟空拔毛变出小猴子的故事情节应该都很熟悉。孙悟空可以用猴毛根据自己的形象复制出很多跟自己一模一样的小猴兵出来，其实在设计模式中也有一个类似的模式，我们可以通过一个原型对象来克隆出多个一模一样的对象，这个模式就是「原型模式」。</p><h3 id="举个例子大同小异的工作周报">举个例子：大同小异的工作周报</h3><p>M 公司一直在使用自行开发的一个 OA 系统进行日常工作办理，但在使用过程中，越来越多的人对工作周报的创建和编写模块产生了抱怨。追其原因，M 公司的 OA 管理员发现，由于某些岗位每周工作存在重复性，工作周报内容都大同小异，如下图所示：</p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210719231225.png" alt="img" /></p><p>这些周报只有一些小地方存在差异，但是现行系统每周默认创建的周报都是空白报表，因此用户只能通过重新输入或不断地复制与粘贴来填写重复的周报内容，极大地降低了工作效率，浪费宝贵的时间。如何快速创建相同或者相似的工作周报，成为了 M 公司软件开发人员的一个新问题。</p><p>M 公司开发人员经过分析，决定按照以下思路对工作周报模块进行重新设计：</p><p>（1）除了允许用户创建新周报外，还允许用户将创建好的周报保存为模板（也就是原型）。</p><p>（2）用户在再次创建周报时，可以创建全新的周报，还可以选择合适的模板复制生成一个相同的周报，然后对新生成的周报根据实际情况进行修改，产生新的周报。</p><h3 id="原型模式概述">原型模式概述</h3><p>从例子可以看出原型模式的定义：</p><p>「<strong>原型模式（Prototype）</strong>」：使用原型实例指定创建对象的种类，并且通过拷贝这些原 型创建新的对象。原型模式是一种对象创建型模式。</p><blockquote><p>原理很简单，将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象克隆自己来实现创建过程。</p><p>PS：需要注意的是，通过克隆方法所创建的对象时全新的对象。</p></blockquote><p>原型模式的结构如下图所示：</p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210719231627.png" alt="img" /></p><p><strong>● Prototype（抽象原型类）：</strong> 它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。</p><p><strong>● ConcretePrototype（具体原型类）：</strong>它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象</p><p><strong>● Client（客户类）：</strong> 让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要<strong>直接实例化或通过工厂方法等方式创建一个原型对象</strong>，再通过<strong>调用该对象的克隆方法即可得到多个相同的对象</strong>。由于客户类针对抽象原型类 Prototype 编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。</p><p>再回到这里，再看下面这张示意图就简单了：</p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210719231025.png" alt="image-20210719231022071" /></p><p>代码实现：</p><p>Image 类：父类</p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210720004647.png" alt="image-20210719233044038" /></p><p>LandSatImage 类 和 SpotImage 类：继承于 Image 的两个子类</p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210720004648.png" alt="image-20210719233432010" /></p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210720004649.png" alt="image-20210719233917331" /></p><p>demo：</p><p><img src="https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210720004650.png" alt="image-20210719234035120" /></p><p>关于面向对象的内存待更新 …… 生命不息，学习不止 ……</p><div style="margin-top:2em;padding:0 1.5em;border:1px solid #d3d3d3;background-color:#deebf7"><h3>文档信息</h3><ul><li>本文作者：<a href="https://isanthree.github.io" target="_blank">stepbystep</a></li><li>本文链接：<a href="https://isanthree.github.io/2021/07/20/oop/" target="_blank">https://isanthree.github.io/2021/07/20/oop/</a></li><li>版权声明：自由转载-非商用-非衍生-保持署名（<a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh" target="_blank">创意共享3.0许可证</a>）</li></ul></div></article><div class="share"></div><div class="comment"><div id="gitalk-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/vendor/gitalk/gitalk.css"> <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script> <script> var gitalk = new Gitalk({ id: '/2021/07/20/oop/', clientID: 'f12aa151f79f6f37d999', clientSecret: '28d34d023131695be5c0e79704ab0c91b54d482c', repo: 'blog-comments', owner: 'isanthree', admin: ['isanthree'], labels: ['gitment'], perPage: 50, }); gitalk.render('gitalk-container'); </script></div></div><div class="column one-fourth"><h1>Search</h1><div id="site_search"> <input style="width:96%" type="text" id="search_box" placeholder="Search"></div><ul id="search_results" style="font-size:14px;list-style-type:none;padding-top:10px;padding-left:10px;"></ul><script src="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/js/simple-jekyll-search.min.js"></script> <script type="text/javascript"> SimpleJekyllSearch({ searchInput: document.getElementById('search_box'), resultsContainer: document.getElementById('search_results'), json: 'https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@built/assets/search_data.json?v=1626792036', searchResultTemplate: '<li><a href="{url}" title="{title}">{title}</a></li>', noResultsText: 'No results found', limit: 100, fuzzy: false, exclude: ['Welcome'] }) </script><h3 class="post-directory-title mobile-hidden">Table of Contents</h3><div id="post-directory-module" class="mobile-hidden"><section class="post-directory"><dl></dl></section></div><script src="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/js/jquery.toc.js"></script></div></div></section><footer class="container"><div class="site-footer" role="contentinfo"><div class="copyright left mobile-block"> © 2017 <span title="stepbystep">stepbystep</span> <a href="javascript:window.scrollTo(0,0)" class="right mobile-visible">TOP</a></div><ul class="site-footer-links right mobile-hidden"><li> <a href="javascript:window.scrollTo(0,0)" >TOP</a></li></ul><a href="https://github.com/isanthree/isanthree.github.io" target="_blank" aria-label="view source code"> <span class="mega-octicon octicon-mark-github" title="GitHub"></span> </a><ul class="site-footer-links mobile-hidden"><li> <a href="https://isanthree.github.io/" title="首页" target="">首页</a></li><li> <a href="https://isanthree.github.io/categories/" title="分类" target="">分类</a></li><li> <a href="https://isanthree.github.io/archives/" title="归档" target="">归档</a></li><li> <a href="https://isanthree.github.io/wiki/" title="维基" target="">维基</a></li><li> <a href="https://isanthree.github.io/links/" title="链接" target="">链接</a></li><li> <a href="https://isanthree.github.io/about/" title="关于" target="">关于</a></li><li><a href="https://isanthree.github.io/feed.xml"><span class="octicon octicon-rss" style="color:orange;"></span></a></li></ul><script async src="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/vendor/busuanzi/2.3/busuanzi.pure.mini.js"></script><div class="mobile-hidden" style="margin-top:8px"> <span id="busuanzi_container_site_pv" style="display:none"> 本站访问量<span id="busuanzi_value_site_pv"></span>次 </span> <span id="busuanzi_container_site_uv" style="display:none"> / 本站访客数<span id="busuanzi_value_site_uv"></span>人 </span> <span id="busuanzi_container_page_pv" style="display:none"> / 本页访问量<span id="busuanzi_value_page_pv"></span>次 / 统计始于2021-05-01 </span></div></div></footer><div class="tools-wrapper"> <a class="gotop" href="#" title="回到顶部"><span class="octicon octicon-arrow-up"></span></a></div><script src="https://cdn.jsdelivr.net/gh/isanthree/isanthree.github.io@master/assets/js/geopattern.js"></script> <script> jQuery(document).ready(function($) { $('.geopattern').each(function(){ $(this).geopattern($(this).data('pattern-id')); }); /* hljs.initHighlightingOnLoad(); */ }); </script><div style="display:none"> <script> (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','https://www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-80669434-1', 'auto'); ga('send', 'pageview'); </script></div></body></html>
