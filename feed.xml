<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.0">Jekyll</generator><link href="https://isanthree.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://isanthree.github.io/" rel="alternate" type="text/html" /><updated>2021-08-04T11:33:49+08:00</updated><id>https://isanthree.github.io/feed.xml</id><title type="html">focus_on_one_thing</title><subtitle>自建个人博客</subtitle><author><name>stepbystep</name></author><entry><title type="html">面向对象编程学习整理</title><link href="https://isanthree.github.io/2021/07/20/oop/" rel="alternate" type="text/html" title="面向对象编程学习整理" /><published>2021-07-20T00:00:00+08:00</published><updated>2021-07-20T00:00:00+08:00</updated><id>https://isanthree.github.io/2021/07/20/oop</id><content type="html" xml:base="https://isanthree.github.io/2021/07/20/oop/">&lt;h1 id=&quot;面向对象编程&quot;&gt;面向对象编程&lt;/h1&gt;

&lt;h2 id=&quot;内联函数inline&quot;&gt;内联函数（inline）&lt;/h2&gt;

&lt;p&gt;inline：在类内定义的函数，都默认为内联函数，类外的函数，则需要在返回类型前添加inline。&lt;/p&gt;

&lt;p&gt;inline只是建议编译构建函数时，构建为内联的，具体是不是则由编译决定。&lt;/p&gt;

&lt;p&gt;inline作用：空间换时间，加快程序的运行速度。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 操作符重载&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;......&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__doapl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;构造函数constructor&quot;&gt;构造函数（constructor）&lt;/h2&gt;

&lt;p&gt;一般使用初始化列表（initialization list）来初始化参数。&lt;/p&gt;

&lt;p&gt;没有在初始化列表中的成员参数会被隐式初始化&lt;/p&gt;

&lt;p&gt;构造函数一般是声明为public，供他人创建，也有声明为 private 的，例如下面的单例模式：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
	&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getInstance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){&lt;/span&gt;&lt;span class=&quot;c1&quot;&gt;//调用函数时，才创建对象&lt;/span&gt;
		&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; 
		&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(){}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在单例模式中，外部无法显式调用构造函数，没有构造函数则无法创建对象，因此将 getInstance() 声明为静态的，可通过类来直接调用。&lt;/p&gt;

&lt;h2 id=&quot;参数的值传递和引用传递&quot;&gt;参数的值传递和引用传递&lt;/h2&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getReal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// const：只读，不能修改对象的数据&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;getImag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;ostream&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ostream&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 在全局定义&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;'('&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;real&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;, &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;sc&quot;&gt;')'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;一般来说，引用传递效率快于值传递，为了提高效率，我们优先使用引用传递参数，避免了参数的复制。若不希望在函数体内对输入参数进行修改，应使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;const&lt;/code&gt;修饰输入参数。若函数的返回值是临时变量，则只能通过值传递返回。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;什么是值传递，什么是引用传递？&lt;/p&gt;

&lt;p&gt;举个比喻性例子：现在有一个包裹，并且需要把它传递出去。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;值传递：把包裹里面的东西全部拷贝到一个临时包裹，整个传过去，无论多大都一起传过去&lt;/li&gt;
  &lt;li&gt;引用传递：把包裹的地址传过去，告诉对方包裹在哪里。这里知道了地址，就知道了包裹有什么东西&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;区别：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;对于大包裹来说，值传递的速度慢，但是引用传递则没有影响，因为只是传了一个地址值，因此引用传递的速度一般快于值传递&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;（传递的包裹或地址，都是对方的需要用到的一个参数）&lt;/p&gt;

    &lt;p&gt;值传递：当对参数进行修改时，不影响原包裹&lt;/p&gt;

    &lt;p&gt;引用传递：当对参数进行修改时，影响原包裹&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
  &lt;li&gt;const：只读
引用传递比值传递快，当我只是想要传递速度快，而不想对方因为修改（编译报错）而影响我原来的包裹时，只需加入 const 关键字&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;==PS：参数传递首先考虑引用。==&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● 问题：什么时候不能使用引用传递？&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;某些局部变量。比如在某函数创建的局部变量，要将该变量传递出去，只能用值传递。因为当所在函数生命周期结束（执行完毕）后，该变量已经不存在，无法将其地址再传给别人。&lt;/p&gt;

&lt;h2 id=&quot;友元&quot;&gt;友元&lt;/h2&gt;

&lt;p&gt;友元函数不受访问级别的控制，可以自由访问对象的所有成员。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__doapl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;friend 赋予其他函数或者类访问类内部&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;protected&lt;/code&gt;或者&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;private&lt;/code&gt;成员的访问权限，打破了类的封装。&lt;/p&gt;

&lt;p&gt;看一个类的成员函数：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;......&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    	&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;re&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;im&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
	&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;im&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;......&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;是不是觉得很奇怪，在类当中，私有的属性，只能由类自己的成员函数去获取，而无法被外界所获取。&lt;/p&gt;

&lt;p&gt;比如，下面的代码：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;complex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;complex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;re&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot; &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;complex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;im&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 私有属性对 complex 对象不可见，编译错误&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;那为什么外界传进来的对象 param 可以去访问 Complex 类的私有属性 re 和 im 呢？&lt;/p&gt;

&lt;p&gt;原因在于：友元会打破类的封装性。==&lt;strong&gt;相同类的各个 objects 互为 friends&lt;/strong&gt;==，在类里面定义一个方法，方法的形参是同类的别的对象，则可以直接获取该对象的私有属性。&lt;/p&gt;

&lt;h2 id=&quot;操作符重载&quot;&gt;操作符重载&lt;/h2&gt;

&lt;p&gt;1、代码片段一：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;complex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 操作符重载&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;complex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;demo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cpp&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如上，编译器怎么看待 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;c2 += c1;&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+=&lt;/code&gt;符号，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+=&lt;/code&gt;是作用在左边（c2）身上的，要是左边的东西要是对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;+=&lt;/code&gt;有定义的话，编译器就找到了。&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;__doapl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ths&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ths&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;re&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;re&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;ths&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;im&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;im&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ths&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__doapl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;c2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;c1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;结合引用来看待以上三个代码片段：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__doapl()、operator+=()、c2 += c1;语句&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;为什么 __doapl() 方法中，定义的返回类型为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Complex &amp;amp;&lt;/code&gt;，但是却返回 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*ths&lt;/code&gt;。因为==传递者是不需要知道接收者是以引用形式接收的==，这就是使用引用的好处。&lt;/p&gt;

&lt;p&gt;看一下 c2 += c1; 语句，首先 c1 是传递者，它要传递到 operator+=(const Complex &amp;amp;r) 中，operator+=() 参数列表中的参数是接收者，由于==传递者是不需要知道接收者是以引用形式接收的==，因此 c1 可以直接传过去；进入函数体内，接下来会进入 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__doapl() 函数&lt;/code&gt;体内；在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__doapl() 函数&lt;/code&gt;中，执行的返回值为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*ths&lt;/code&gt;，但是定义的返回类型为 Complex &amp;amp;，这是因为在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;__doapl() 函数&lt;/code&gt;这里，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*ths&lt;/code&gt;是传递者，将要接收 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;*ths&lt;/code&gt;的接收者的类型这里定义为 Complex &amp;amp;，由于==传递者是不需要知道接收者是以引用形式接收的==，因此可以 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;return *ths&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;2、代码片段二：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;real&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;real&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;imag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;前面说过，引用传递在「将要被传递的变量是局部的」这种情况下必须使用值传递。假如要用引用传递，我们看一下代码，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;real(x) + real(y)&lt;/code&gt;运算后，存放结果的对象在哪里，必然需要在函数内部创建一个对象来存储，这个对象在函数生命周期结束时就会立即释放，传递出去的引用将是无效的，因此定义的返回类型为 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Complex&lt;/code&gt;，而不是引用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Complex &amp;amp;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;3、代码片段三：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;real&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;imag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;上面这个对「正负号」的重载函数是从标准库中摘抄下来的。也许有人会说，上面不是说==传递者不需要接收者是以引用形式接收的==吗？x 不是局部变量，优先考虑引用传递，那么正号重载函数为什么不使用引用呢？&lt;/p&gt;

&lt;p&gt;答：也可以使用引用，而且速度更快，这里或许说明类即使是标准库，设计的程序性能也不一定是最好的。（有人说是为了正负号重载函数设计的对称美，舍弃了引用）改写如下：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外，operator - () 只能使用值传递，因为创建的是临时对象。&lt;/p&gt;

&lt;h2 id=&quot;拷贝构造函数拷贝赋值函数和析构函数&quot;&gt;拷贝构造函数、拷贝赋值函数和析构函数&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;这三个函数，在欧洲被称为 “Big Three”，三大件，三位一体。&lt;/p&gt;

  &lt;p&gt;对于不带有指针的类，这「三大件」可以使用编译器默认为我们生成的版本；但是编写带有指针的类时，我们就有必要定义这三个特殊函数。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;发现没有，上面举的关于类的例子，都是不带指针的，但是，在 C++ 中，指针是经常被使用的东西，我们知道，当类里面存在指针时，需要自己定义拷贝函数，有没有思考过：如果不自己定义实现而使用库的，会出现什么问题？&lt;/p&gt;

&lt;p&gt;我们来看一下这个类：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;......&lt;/span&gt;

  &lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;==浅拷贝==：假设 String 类有 a 和 b 两个实例对象，a 的数据为 “Hello”，b 的数据为 “World”，即 a 中的 m_data 指针指向的内存块存着字符串 “Hello”，b 的 m_data 指针指向的则为 “World”，但是，”Hello” 和 “World” 都不是属于类里面的成员。当我们使用库提供的拷贝时，不妨假设 a = b; 即把 b 的数据拷贝给 a，此时 a 的 m_data 指针也指向 “World” 了，这样看似也是可以得到想要的值，a 的 m_data 指针和 b 的相同了，都指向了同一块内存空间。但是，此时问题出现了，存着 “Hello” 的那一块内存没有指针指着了，也就是说造成了内存泄漏，这就是一个大问题。另外还有一个问题，一块内存被两个指针指着，这是一件很危险的事，当 b 的指针修改了这块内存的值，a 将会受到影响，不可取。&lt;/p&gt;

&lt;p&gt;==深拷贝==：而使用自己定义的拷贝函数的话，不改变 a 的 m_data 指针值，而是将 b 的数据 “World” 直接拷贝一份放到 a 的 m_data 指针指向的内存空间，解决类内存泄漏的问题。&lt;/p&gt;

&lt;p&gt;深拷贝和浅拷贝是要说的重点，现在简要说一下这三个函数，直接 show you code，一目了然：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// 拷贝构造&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 析构函数：在类的生命周期即将结束前执行，内存回收，释放掉动态申请的内存&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// 拷贝赋值&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;cm&quot;&gt;/**
     * 检测自我赋值 self assigment
     * 很重要，如果没有自我检视并返回，就会进入未知风险状态：
     * 先把自己的内存释放掉，然后再照着“自己的内存”申请相同的内存大小，可能引发未知错误
     */&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;                           &lt;span class=&quot;c1&quot;&gt;// 先释放自己原来的内存&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;strlen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 再重新申请一块大小相等内存&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;strcpy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;栈堆内存分配&quot;&gt;栈、堆、内存分配&lt;/h2&gt;

&lt;h3 id=&quot;内存分配&quot;&gt;内存分配&lt;/h3&gt;

&lt;p&gt;看一段代码：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这一行语句，在编译器看来做了什么？实际上，C++ 编译器执行这条语句，分为了三个步骤：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mem&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;sizeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 分配内存&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mem&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 类型转换&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// 调用构造函数&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;显然，首先获得一块内存，operator new 其内部调用的 malloc() 去动态申请一块内存，这里 C++ 已经给我们封装好了；然后对指针进行类型转化；最后通过转型后的指针去调用构造函数完成对象的初始化。&lt;/p&gt;

&lt;p&gt;new 的示意图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720215936.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;再来看一段代码：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;......&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete pc;&lt;/code&gt;这个语句在编译器看来，是怎么执行的呢？&lt;/p&gt;

&lt;p&gt;这里再次 show you the code：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Complex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 析构函数&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 释放内存&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;显然，可以看到，删除 pc 指针，将分为两步进行，第一步：调用析构函数，释放类的属性成员指针指向的内存；第二步，释放该指针动态实例化的类对象。&lt;/p&gt;

&lt;p&gt;delete 的示意图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720215835.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;demo-代码&quot;&gt;demo 代码&lt;/h4&gt;

&lt;p&gt;demo：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;cstdlib&amp;gt;
#include &amp;lt;iostream&amp;gt;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;constructor:&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;destory:&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;new&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;delete&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[](&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;new[]&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;malloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[](&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;delete[]&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;free&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;A&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;输出：&lt;/p&gt;

&lt;div class=&quot;language-json highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;err&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;constructor:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;xffa&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;998&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;destory:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;xffa&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;998&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;constructor:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;xffa&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;constructor:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;xffa&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;constructor:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;xffa&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;destory:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;xffa&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;destory:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;xffa&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;d&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;destory:&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;xffa&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;99&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;堆栈&quot;&gt;堆、栈&lt;/h3&gt;

&lt;p&gt;VC 中对象在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;debug&lt;/code&gt;模式和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;release&lt;/code&gt;模式下的内存分布如下图所示,变量在内存中所占字节数必须被补齐为16的倍数,红色代表&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;cookie&lt;/code&gt;保存内存块的大小,其最低位的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;1&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;0&lt;/code&gt;分别表示内存是否被回收。&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Complex 对象&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;String 对象&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720221014.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720221022.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;数组中的元素是连续的，数组头部 4 个字节记录了数组长度：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Complex 对象&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;String 对象&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720221416.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720221432.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;blockquote&gt;
  &lt;p&gt;学习关于对象或对象数组申请这一部分的堆栈，是为了更好地了解编译器的行为，从而帮助我们更好地理解 new 和 delete 和内存相关的操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们都知道，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new[]&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete[]&lt;/code&gt;应该配对使用。为什么要这样做呢？不这样做的后果是什么？学习了内存，根据数组在内存中的状态，自然可以理解为什么这样做了:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt;操作符仅会调用一次析构函数，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete[]&lt;/code&gt;操作符依次对每个对象调用析构函数，对于&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;String&lt;/code&gt;这样带有指针的类，若将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete[]&lt;/code&gt;误用为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;delete&lt;/code&gt;会引起内存泄漏，如下图所示，将造成剩下的两个 String 成员变量指针所指向内存的泄漏。&lt;/p&gt;

&lt;p&gt;流程如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720222250.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;static-成员&quot;&gt;static 成员&lt;/h2&gt;

&lt;p&gt;对于类来说，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;non-static&lt;/code&gt;成员变量每个对象均存在一份，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt;成员变量、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;non-static&lt;/code&gt;和&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt;成员函数在内存中仅存在一份。其中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;non-static&lt;/code&gt;成员函数通过指定&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this&lt;/code&gt;指针获得函数的调用权，而&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt;函数不需要&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;this&lt;/code&gt;指针即可调用.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720222646.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt;成员函数可以通过对象调用，也可以通过类名调用：&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Account&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_rate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;set_rate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;m_rate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m_rate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mf&quot;&gt;8.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_rate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;5.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;Account&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_rate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;7.0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static&lt;/code&gt;成员变量需要在类声明体外进行初始化。&lt;/p&gt;

&lt;h1 id=&quot;类之间的关系&quot;&gt;类之间的关系&lt;/h1&gt;

&lt;h2 id=&quot;复合composition&quot;&gt;复合（composition）&lt;/h2&gt;

&lt;p&gt;复合表示一种&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;has-a&lt;/code&gt;的关系，即类的成员存在一个或多个别的类，STL 中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;queue&lt;/code&gt;的实现就使用了复合关系。这种结构也被称为「&lt;strong&gt;adapter 模式&lt;/strong&gt;」。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720224617.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;复合关系下构造由内而外，析构由外而内：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720224623.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;委托aggregation-composition-by-reference&quot;&gt;委托（aggregation; composition by reference）&lt;/h2&gt;

&lt;p&gt;pointer to implement(Handle/Body)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720224629.png&quot; alt=&quot;请添加图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;委托将类的定义与类的实现分隔开来，也被称为「编译防火墙」。&lt;/p&gt;

&lt;h2 id=&quot;继承extension&quot;&gt;继承（extension）&lt;/h2&gt;

&lt;p&gt;继承表示一种&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;is-a&lt;/code&gt;的关系，STL 中&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;_List_node&lt;/code&gt;的实现就使用了继承关系.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720224634.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;继承关系下，构造由内而外，析构由外而内：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720224639.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;父类的析构函数必须是 virtual，否则会出现 undefine behavior&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;虚函数&quot;&gt;虚函数&lt;/h3&gt;

&lt;p&gt;成员函数有 3 种：非虚函数、虚函数和纯虚函数:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;非虚（non-virtual）函數：不希望子类重新定义（override，复写）的函数&lt;/li&gt;
  &lt;li&gt;虚（virtual）函數：子类可以重新定义（override，复写）的函数，且有默认定义&lt;/li&gt;
  &lt;li&gt;纯虚(pure virtual)函數：子类必须重新定义（override，复写）的函数，没有默认定义&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720224644.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虚函数的使用举例说明：「使用虚函数框架」，假设有一个人想要实现一个一般性的文件处理类，这个文件处理过程包括：打开文件、读取文件、关闭文件，现在的思路是，在这个文件处理类里面实现「打开文件」、「关闭文件」这两个操作，但是，「读取文件」操作留给用户定义，因为作者不知道用户要以什么样的方式（格式）去读取这个文件，此时，「读取文件」操作就可以用虚函数来写，不给出具体定义或实现，让用户（子类）去复写，这就是大体的框架。下面是代码流程示例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720224647.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图，框架中父类&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CDocument&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Serialize()&lt;/code&gt;函数设为虚函数，由框架使用者编写的子类&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CMyDoc&lt;/code&gt;定义具体的文件处理过程，代码如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720224652.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;虚函数是很实用的，因为很多时候，设计者设计的都只是一个框架，里面涉及了哪些功能，设计者都已经给我们想好了，这些都是固定的功能。但是，有另外一些功能是需要私人定制的，根据不同的需求有不同的实现，那么将这些功能函数声明为虚函数，由用户来定义实现，就显得很必要了。&lt;/p&gt;

&lt;h1 id=&quot;面向对象设计范例&quot;&gt;面向对象设计范例&lt;/h1&gt;

&lt;h2 id=&quot;使用委托--继承实现-observer-模式&quot;&gt;使用委托 + 继承实现 Observer 模式&lt;/h2&gt;

&lt;p&gt;解决的问题：一个文件，四个窗口，当文件变化时，窗口也会跟着改变。&lt;/p&gt;

&lt;p&gt;使用 Observer 模式实现多个窗口订阅同一份内容并保持实时更新：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720224656.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/p&gt;

&lt;p&gt;类结构如下图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.fastgit.org/isanthree/blog-gallery/master/pic/20210719222654.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;使用委托继承实现-composite-模式&quot;&gt;使用委托+继承实现 Composite 模式&lt;/h2&gt;

&lt;p&gt;使用 Composite 模式实现多态，类结构图如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720224701.png&quot; alt=&quot;在这里插入图片描述&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;使用委托继承实现-prototype-模式&quot;&gt;使用委托+继承实现 Prototype 模式&lt;/h2&gt;

&lt;p&gt;看一张图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720224943.png&quot; alt=&quot;image-20210719231022071&quot; /&gt;&lt;/p&gt;

&lt;p&gt;上面的图一开始看的一头雾水，不急，先看比较贴近生活的东西。&lt;/p&gt;

&lt;p&gt;相信大多数的人都看过《西游记》，对孙悟空拔毛变出小猴子的故事情节应该都很熟悉。孙悟空可以用猴毛根据自己的形象复制出很多跟自己一模一样的小猴兵出来，其实在设计模式中也有一个类似的模式，我们可以通过一个原型对象来克隆出多个一模一样的对象，这个模式就是「原型模式」。&lt;/p&gt;

&lt;h3 id=&quot;举个例子大同小异的工作周报&quot;&gt;举个例子：大同小异的工作周报&lt;/h3&gt;

&lt;p&gt;M 公司一直在使用自行开发的一个 OA 系统进行日常工作办理，但在使用过程中，越来越多的人对工作周报的创建和编写模块产生了抱怨。追其原因，M 公司的 OA 管理员发现，由于某些岗位每周工作存在重复性，工作周报内容都大同小异，如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720224948.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这些周报只有一些小地方存在差异，但是现行系统每周默认创建的周报都是空白报表，因此用户只能通过重新输入或不断地复制与粘贴来填写重复的周报内容，极大地降低了工作效率，浪费宝贵的时间。如何快速创建相同或者相似的工作周报，成为了 M 公司软件开发人员的一个新问题。&lt;/p&gt;

&lt;p&gt;M 公司开发人员经过分析，决定按照以下思路对工作周报模块进行重新设计：&lt;/p&gt;

&lt;p&gt;（1）除了允许用户创建新周报外，还允许用户将创建好的周报保存为模板（也就是原型）。&lt;/p&gt;

&lt;p&gt;（2）用户在再次创建周报时，可以创建全新的周报，还可以选择合适的模板复制生成一个相同的周报，然后对新生成的周报根据实际情况进行修改，产生新的周报。&lt;/p&gt;

&lt;h3 id=&quot;原型模式概述&quot;&gt;原型模式概述&lt;/h3&gt;

&lt;p&gt;从例子可以看出原型模式的定义：&lt;/p&gt;

&lt;p&gt;「&lt;strong&gt;原型模式（Prototype）&lt;/strong&gt;」：使用原型实例指定创建对象的种类，并且通过拷贝这些原 型创建新的对象。原型模式是一种对象创建型模式。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;原理很简单，将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象克隆自己来实现创建过程。&lt;/p&gt;

  &lt;p&gt;PS：需要注意的是，通过克隆方法所创建的对象时全新的对象。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;原型模式的结构如下图所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720224951.png&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● Prototype（抽象原型类）：&lt;/strong&gt; 它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● ConcretePrototype（具体原型类）：&lt;/strong&gt;它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;● Client（客户类）：&lt;/strong&gt; 让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要&lt;strong&gt;直接实例化或通过工厂方法等方式创建一个原型对象&lt;/strong&gt;，再通过&lt;strong&gt;调用该对象的克隆方法即可得到多个相同的对象&lt;/strong&gt;。由于客户类针对抽象原型类 Prototype 编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。&lt;/p&gt;

&lt;p&gt;再回到这里，再看下面这张示意图就简单了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720224943.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;代码实现：&lt;/p&gt;

&lt;p&gt;Image 类：父类&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720225509.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;LandSatImage 类 和 SpotImage 类：继承于 Image 的两个子类&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720225603.png&quot; alt=&quot;image-20210719233432010&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720225609.png&quot; alt=&quot;image-20210719233917331&quot; /&gt;&lt;/p&gt;

&lt;p&gt;demo：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210720225006.png&quot; alt=&quot;image-20210719234035120&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于面向对象的内存待更新 …… 生命不息，学习不止 ……&lt;/p&gt;</content><author><name>stepbystep</name></author><category term="OOP" /><summary type="html">面向对象编程</summary></entry><entry><title type="html">祝贺中国共产党建党 100 周年</title><link href="https://isanthree.github.io/2021/07/01/100th-anniversary-of-the-Communist-Party-of-China/" rel="alternate" type="text/html" title="祝贺中国共产党建党 100 周年" /><published>2021-07-01T00:00:00+08:00</published><updated>2021-07-01T00:00:00+08:00</updated><id>https://isanthree.github.io/2021/07/01/100th-anniversary-of-the-Communist-Party-of-China</id><content type="html" xml:base="https://isanthree.github.io/2021/07/01/100th-anniversary-of-the-Communist-Party-of-China/">&lt;p&gt;中国共产党建党 100 周年，祝福祖国繁荣昌盛！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210701113911.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://gitee.com/juststepbystep/pic-bed/raw/master/pic/20210701113928.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;</content><author><name>stepbystep</name></author><category term="碎碎念" /><summary type="html">中国共产党建党 100 周年，祝福祖国繁荣昌盛！</summary></entry><entry><title type="html">拜拜，大学！拜拜。长沙！</title><link href="https://isanthree.github.io/2021/06/17/Goobye-all-my-university/" rel="alternate" type="text/html" title="拜拜，大学！拜拜。长沙！" /><published>2021-06-17T00:00:00+08:00</published><updated>2021-06-17T00:00:00+08:00</updated><id>https://isanthree.github.io/2021/06/17/Goobye-all-my-university</id><content type="html" xml:base="https://isanthree.github.io/2021/06/17/Goobye-all-my-university/">&lt;p&gt;今晚，将是我在长沙大学生涯的最后一晚，昨天开完毕业典礼，领完毕业证，既开心又惆怅，或者，大概是太多不舍，还有曾经某些事、某些时光的意难平，在大家各奔东西之际，五味杂陈 ……&lt;/p&gt;

&lt;p&gt;无论怎么样，望以后的生活，平淡而精彩，奋斗常态 ……&lt;/p&gt;

&lt;p&gt;另外，「神舟 12 号」发射成功，聂海胜、刘伯明和汤洪波进驻空间站，祝贺中国航天！祝贺祖国！&lt;/p&gt;</content><author><name>stepbystep</name></author><category term="碎碎念" /><summary type="html">今晚，将是我在长沙大学生涯的最后一晚，昨天开完毕业典礼，领完毕业证，既开心又惆怅，或者，大概是太多不舍，还有曾经某些事、某些时光的意难平，在大家各奔东西之际，五味杂陈 ……</summary></entry><entry><title type="html">win10 配置右键新建 markdown 文件</title><link href="https://isanthree.github.io/2021/05/30/Win10-right-click-to-create-markdown/" rel="alternate" type="text/html" title="win10 配置右键新建 markdown 文件" /><published>2021-05-30T00:00:00+08:00</published><updated>2021-05-30T00:00:00+08:00</updated><id>https://isanthree.github.io/2021/05/30/Win10-right-click-to-create-markdown</id><content type="html" xml:base="https://isanthree.github.io/2021/05/30/Win10-right-click-to-create-markdown/">&lt;p&gt;本文介绍了如何在Windows操作系统中添加右键创建.md文件的方法。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;打开注册表&lt;/p&gt;

    &lt;p&gt;CMD+R，打开运行对话框；输入regedit，打开注册表编辑器&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;修改注册表&lt;/p&gt;

    &lt;p&gt;在&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;计算机&amp;gt;HKEY_CLASSES_ROOT&lt;/code&gt;右键查找，输入&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Typora&lt;/code&gt;，勾选项，取消勾选值和数据&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/isanthree/blog-gallery/pic/20210530094612.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;确认运行的程序名字，我的电脑如图所示，运行文件是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Typora.exe&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/isanthree/blog-gallery/pic/20210530094821.png&quot; style=&quot;zoom: 80%;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;创建注册表&lt;/p&gt;

    &lt;p&gt;在磁盘任意位置新建一个文件，后缀为.reg；&lt;/p&gt;

    &lt;p&gt;打开编辑刚刚创建好的注册表文件，写入以下内容：&lt;/p&gt;

    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Windows Registry Editor Version 5.00
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;HKEY_CLASSES_ROOT&lt;span class=&quot;se&quot;&gt;\.&lt;/span&gt;md]
@&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Typora.exe&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;HKEY_CLASSES_ROOT&lt;span class=&quot;se&quot;&gt;\.&lt;/span&gt;md&lt;span class=&quot;se&quot;&gt;\S&lt;/span&gt;hellNew]
&lt;span class=&quot;s2&quot;&gt;&quot;NullFile&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;HKEY_CLASSES_ROOT&lt;span class=&quot;se&quot;&gt;\T&lt;/span&gt;ypora.exe]
@&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Markdown&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;

    &lt;blockquote&gt;
      &lt;p&gt;@=”Typora.exe” 代表的是指定 .md 文件的运行程序&lt;/p&gt;

      &lt;p&gt;@=”Markdown” 代表的是右键时默认的文件名字，这样写新建为&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;新建Markdown.md&lt;/code&gt;文件，而且右键菜单中显示&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MarkDown&lt;/code&gt;&lt;/p&gt;
    &lt;/blockquote&gt;

    &lt;p&gt;编辑好之后,另存为，设置如图所示：&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/isanthree/blog-gallery/pic/20210530095526.png&quot; alt=&quot;image-20210530095406930&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;文件名可以随便设置，但是后缀必须是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.reg&lt;/code&gt;文件,保存类型一定要是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;文本文档(*.txt)&lt;/code&gt;,编码选择&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ANSI&lt;/code&gt;,非常重要！&lt;/p&gt;

    &lt;p&gt;保存文件后,双击运行，修改注册表即可，现在右键即可达到预期效果，如果不行，请重启一下。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;</content><author><name>stepbystep</name></author><category term="环境配置" /><summary type="html">本文介绍了如何在Windows操作系统中添加右键创建.md文件的方法。</summary></entry><entry><title type="html">答辩结束，我毕业啦</title><link href="https://isanthree.github.io/2021/05/23/End-of-college-career/" rel="alternate" type="text/html" title="答辩结束，我毕业啦" /><published>2021-05-23T00:00:00+08:00</published><updated>2021-05-23T00:00:00+08:00</updated><id>https://isanthree.github.io/2021/05/23/End-of-college-career</id><content type="html" xml:base="https://isanthree.github.io/2021/05/23/End-of-college-career/">&lt;p&gt;今天是2021年5月23日，大学生涯随着答辩的结束，彻底画下句号，我终于……毕业啦！&lt;/p&gt;

&lt;p&gt;除了高考，前所未有的，放松 …… 这一路走来，毕设的过程，蛮难受的 …… 此刻，一切都结束了，大学的一些人，一些事，只能留待以后的人生来怀念，大抵是说不出的另外的一种惆怅感觉了 ……&lt;/p&gt;

&lt;p&gt;下午完成最后一项任务，为党支部接收一批新的党员，好好干吧！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/isanthree/blog-gallery/pic/20210523134522.jpg&quot; alt=&quot;img&quot; /&gt;&lt;/p&gt;</content><author><name>stepbystep</name></author><category term="碎碎念" /><summary type="html">今天是2021年5月23日，大学生涯随着答辩的结束，彻底画下句号，我终于……毕业啦！</summary></entry><entry><title type="html">火车驶向云外，梦安魂于九霄</title><link href="https://isanthree.github.io/2021/05/20/small-daily/" rel="alternate" type="text/html" title="火车驶向云外，梦安魂于九霄" /><published>2021-05-20T00:00:00+08:00</published><updated>2021-05-20T00:00:00+08:00</updated><id>https://isanthree.github.io/2021/05/20/small-daily</id><content type="html" xml:base="https://isanthree.github.io/2021/05/20/small-daily/">&lt;p&gt;Content here&lt;/p&gt;

&lt;p&gt;摇旗呐喊的热情 携光阴渐远去&lt;/p&gt;

&lt;p&gt;人世间悲喜烂剧 昼夜轮播不停&lt;/p&gt;

&lt;p&gt;纷飞的滥情男女 情仇爱恨别离&lt;/p&gt;

&lt;p&gt;一代人终将老去 但总有人正年轻&lt;/p&gt;

&lt;p&gt;——刺猬 《火车驶向云外，梦安魂于九霄》&lt;/p&gt;</content><author><name>stepbystep</name></author><category term="碎碎念" /><summary type="html">Content here</summary></entry><entry><title type="html">档案相关</title><link href="https://isanthree.github.io/2021/05/19/about-archives/" rel="alternate" type="text/html" title="档案相关" /><published>2021-05-19T00:00:00+08:00</published><updated>2021-05-19T00:00:00+08:00</updated><id>https://isanthree.github.io/2021/05/19/about-archives</id><content type="html" xml:base="https://isanthree.github.io/2021/05/19/about-archives/">&lt;p&gt;快毕业了，最近被档案这事搞得有点烦，班群里面发了一个word，关于档案，为了防止不小心删了，也为了更好找到，就搬到这里来了。&lt;/p&gt;

&lt;p&gt;原文：&lt;/p&gt;

&lt;p&gt;毕业N年后，请不要像我一样被档案烦死(转自一位已经毕业的学姐)&lt;/p&gt;

&lt;h2 id=&quot;一-提醒大学生深刻重视档案避免以后麻烦&quot;&gt;一. 提醒大学生：深刻重视档案，避免以后麻烦！&lt;/h2&gt;

&lt;p&gt;大学毕业最痛苦的是搞不定档案和户口。户口，一般不会丢，大家都很当回事，毕竟身份证一丢，马上就要处理户口。但就是这个档案，却是很多人不当回事。但是只要你是活在中国的毕业大学生，你肯定就会碰到档案的事情。作为一个毕业了5年左右的毕业生，回头去看档案，毫无疑问，是相当重要的，如果有机会重来，我自己一定会这“档”子事搞好。如果你毕业N年后不想像我现在烦躁不已，那么请静下心来认真看下这篇文章!在毕业时花些时间，把档案这件事情处理好，会减少许多以后不必要的麻烦。请各位深刻重视。&lt;/p&gt;

&lt;h2 id=&quot;二-说说我因为档案造成的烦心事&quot;&gt;二. 说说我因为档案造成的烦心事！&lt;/h2&gt;

&lt;p&gt;为了方便大家了解大学生档案的重要性，说下我的经历。我大学毕业的时候，是在厦门的一家国有企业工作，所以毕业时候的户口. 档案都调到国有企业去了（国有企业和我们签订了3年的就业合同，如果我们提前离职，就要赔违约金，否则就扣押住档案）。在国有企业工作快三年时间，对国有企业很是失望，国企管理松懈，整天清闲，觉得无聊，工资也不高，20来岁干的确是60岁人就能干的工作，深深为自己的前途担忧。所以总是去思考出路。后来机缘巧合对计算机感兴趣了，毕竟互联网和电子商务的发展有目共睹。偶尔看传智播客韩顺平老师的《php从入门到精通》讲的非常不错，就从国企辞职到了北京传智播客学php。结业后很幸运的就在直接就进入了互联网行业，工资直接是我在国企的三倍，所以我也就留在了北京，叫在厦门的同事帮我处理离职的事情。在这里，就出现了档案问题了，不知怎么回事档案却被同事转寄送到我手里来了。由于在北京工作，北京的人才市场是不接非北京户口档案，而北京的这家公司没档案也依然给我上保险。把档案存在人事代理公司，自己也是非常不放心。所以工作一忙我也就没有去处理档案（存哪里都不合适），就一直放在手上了。&lt;/p&gt;

&lt;p&gt;现在两年过去了，由于档案一直在我手里，档案已经成为“死档”了。我就算办理了结婚证，也无法办理准生证，糟糕透了。打电话咨询我们县人事局档案专员，竟然告诉我这两年没有工龄。更重要的是我想考职称没法考。因为这两年没有工龄，而我要考的职称需要3年工龄。其实我已经工作五年了，社保却无法作证，偏要这个北京人才市场不接受的档案作证。咨询北京人事代理公司“档案激活”业务，询问到费用，对方虽说具体面谈，但是起步价就要8000元，还上不封顶。因为现在不办，以后我也得办，晚办不如早班，早办毕竟工龄能多算！这笔费用，看来是被吃定了，想想都郁闷烦心！&lt;/p&gt;

&lt;p&gt;虽然烦心，但最近这几天的反复查询网站，和老家人事局. 北京人事代理公司. 厦门人才市场反复打电话，总算搞明白档案这档子事！特分享给大学的朋友们！一定要认真看，不要N年后跟我一样麻烦！&lt;/p&gt;

&lt;h2 id=&quot;三-说说档案这档子事&quot;&gt;三. 说说档案这档子事：&lt;/h2&gt;

&lt;p&gt;档案是什么？
档案大部分时间自己是看不到的，都是由相关部门进行托管。档案对于工作的人来说是计算工龄的一个重要凭证。具体可以百度“人事档案”，有相关百科，在此由于篇幅限制，不再过多赘述。&lt;/p&gt;

&lt;p&gt;档案的作用：
下面具体讲讲几个我们没有档案，办理会非常麻烦的几个事情：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;转正定级，获取干部身份。必须在第一家单位就业工作满一年，申请转正定级，才会获得干部身份了。干部身份有什么用，百度百科“干部身份”。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;考研；&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;考公务员，没有人事档案，没有办法过政审这关。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;评职称，如果没有档案，你就没有干部身份，也就没有资格评职称。而职称往往是和工资和户口积分挂钩的（天津就是这样）。有职称，也是求职的一个砝码！&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;考资格证，比如会计专业资格考试等，考试需要和人事档案的地点相同，没有人事档案，你报名都可能报不上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;办理准生证，都需要男方存档案的地方开婚育证明，档案都不知道在哪里，你怎么开！&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;出国审查，没有档案，政审就无法进行&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;养老保险。工龄计算，必须要档案！退休后要拿到退休金，必须要档案，档案是否完备，也将影响到退休金的高低。（根据2010年出台的相关文件，自2011年1月1日起，无档案人员也可以以养老保险实际缴纳年限来办理退休手续，但办理过程非常麻烦。）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;某些大城市，比如上海，办理居住证，前提是将档案调到上海。没有档案，就没有办法办理居住证，也就没有办法落户上海了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;进国企，事业单位需要档案，而且这是一个非常重要的材料。如果你没有档案且不及时补救，那么这种好单位的大门也会向你关上。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;住房补贴发放&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;入团入党。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;档案重要吗？如果你这辈子跟上面12件事无关，你确实无需操心档案，如果不幸的是12件事情中哪怕只有1件，你档案如果丢失了也将会很麻烦。所以千万不要当“弃档族”！&lt;/p&gt;

&lt;h2 id=&quot;四-档案如此重要为什么有些人却成了弃档族&quot;&gt;四. 档案如此重要，为什么有些人却成了弃档族？&lt;/h2&gt;

&lt;p&gt;档案很重要，人事档案没处理好将给自己带来很多麻烦。但对档案“置之不理”的大学毕业生却不在少数。但却有调查显示，有近四成高学历求职者都加入了“弃档族”，很多毕业生根本不知道自己的档案放在哪里！&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;首先是就业指导老师阐述的不太清楚，就是你当面去问他都有可能问不清楚。毕竟对于一些不负责任的就业老师而言，只要将学员的档案从学校转出去，工作就算是做到位了，很难将档案和毕业生未来生活关系阐述清楚。照本宣科的讲规章制度，或只是去强调“这是国家规定的”，导致大学生们茫然，就算知道重要但却不知道如何具体去处理，不知不觉中就成了弃档族。&lt;/li&gt;
  &lt;li&gt;网上对于档案的重要性，众说纷纭。有的说重要，也有很多人说不重要。就算是有帖子阐述了档案的重要性，但却对于如何处理档案却也没有说的详细清楚。学员们无法根据自己的实际情况采取相应的办法，不知不觉中就成了弃档族。&lt;/li&gt;
  &lt;li&gt;其次是目前的很多企业不具备存放档案是资格，再加上现在的绝大部分企业没有档案一样可以上社保，一样可以上班，一样可以领工资。所以我们就理所当然的就认为档案不重要。&lt;/li&gt;
  &lt;li&gt;如果是在私企，我们身边的很多人都搞不清楚档案的事情，甚至是人事也不清楚档案作用。不仅不清楚，而且时常会给你灌输档案没有什么作用，让你真就以为档案没有什么作用了。&lt;/li&gt;
  &lt;li&gt;某些地方人才市场（比如北京）对于非户籍人员咨询，态度冷漠，只告诉能不能入而不会告诉你应该怎么办！一不小心，自己就成为弃档族了。&lt;/li&gt;
  &lt;li&gt;很多人因为档案丢失而造成的麻烦也不会去说（其实网上百度就知道，太多人由于档案丢失造成麻烦），去给他人预警和提示。所以大家一个个就掉进坑里去了。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;五-档案该怎么操作才能不当弃档族非常重要认真看&quot;&gt;五. 档案该怎么操作才能不当“弃档族”？非常重要，认真看!&lt;/h2&gt;

&lt;p&gt;强调档案的两个重要的注意事项:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;毕业后档案不能放在自己手里。可以存放学校. 生源地人事局. 人才市场. 劳动局，街道办事处，职介，否则就是死档！&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;毕业后自己的第一份工作，如果档案转到单位或当地人才中心，一定要记得干满一年，然后向单位或人才申请转正定级，获得干部身份（干部身份的好处，可以百度）。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;下面就结合我们毕业生的各种情况，详细谈谈我们应如何处理我们的户口档案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;毕业后档案存放学校（注意2年期限）：
 如果毕业后没有及时找到合适工作（或考研），导致毕业即失业，可以到学校申请暂缓就业，在两年内找到工作的，一定要及时回校办理档案转移，到学校将户籍和档案迁至工作单位所在地或单位所在地的人才市场。两年过后，学校就会打回原籍，很可能造成档案丢失。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;毕业后档案存放人才市场（建议）：&lt;/p&gt;

    &lt;p&gt;1) 毕业没有找到单位的（或考研），可以去学校或单位所在的人才市场进行档案挂靠，千万不能弃档。人才市场都是人事局办的，是官方机构，这是政府部门，拥有档案保管权，有权办理转正定级，放在那里起码有安全保障。但要提醒的是， 一旦找到工作要及时办理就业手续，以便能够及时的进行转正定级，方便后面的正式调动。如果没有找到工作，也要记得人才交流中心的集体户口是属于临时户口，有两年的限期，毕业超过两年就不能继续托管了，会变成“死档”。一定要记得去处理。可以自己申请打回原籍，以免档案丢失。&lt;/p&gt;

    &lt;p&gt;2) 毕业后找到单位的，可放心的找就业地方人才市场挂靠，而且挂靠的人才市场可能会接收个人手上的档案。从存放在人才市场之日开始，就可以算我们的工龄了。就算以后到别的地方发展，也可以通过发调档函，很方便的转到新就业地人才市场。这样既不影响在当地工作，也不影响职称’晋级’，工龄还能连续计算，顺畅地完成衔接。这里有个注意点是找到的第一份单位工作如果未做满一年，无法请求人才市场进行转正定级，将会失去干部身份。所以如果我们一定要离职，也一定要等到我们的第一份工作做满一年已经申请转正定级获得干部身份后。&lt;/p&gt;

    &lt;p&gt;3) 毕业后找到单位后又辞职到其他地方去的，这里还有个注意点：某些地方的人才市场5年内如果没有交档案保管费，人才市场保管档案的义务就会自动解除，档案会被封存，我们的档案会成为“死档”（35岁之前可以档案激活，35岁之后，就麻烦了）！&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;毕业后档案主动打回原籍（建议）&lt;/strong&gt;：
 不管是否参加工作，都可将自己的档案拿回到原籍人事局或人才市场，省的以后麻烦，毕竟以后如果有事情可以让父母帮着处理。把档案放在家乡的人才市场，以后在外地找到工作后不会麻烦，一方面工作又不需要档案，就算是是找到国企. 考到公务员，单位发函到你家乡人才市场调档案就可以了。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;毕业后档案寄送公司/单位（不太建议）&lt;/strong&gt;：
 现在一般公司都是把员工档案统一放在公司所在区的人才市场的。建议档案还是不要归公司管理，以防自己离职的时候档案很有可能被公司扣留。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;档案存放在街道办事处（尽量不要）&lt;/strong&gt;：
 档案在街道的话，一旦有单位录用你需要调取档案的话比较的麻烦。而且档案放在街道一样要交存档费用。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;六-很多人档案会成为死档的三种原因&quot;&gt;六. 很多人档案会成为“死档”的三种原因&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;档案丢失会成为“死档”。
    毕业生择业期为两年，因此择业期间可申请学校代管两年。放在学校两年期满后仍未落实工作的（或找到工作未及时来学校处理的），学校就会将档案和户口一起打回原籍了（或转到学生户口所在地的人才交流中心，或转至生源地所在地级市的人事局或教育局接收）。这里需要强调的是，在打回的过程中很容易把档案搞丢。所以要么两年内去落实工作，要么自己去办理户口和档案转移到某个人才市场或转移到家里去。很多人成为弃档族，就是这里搞丢了！&lt;/li&gt;
  &lt;li&gt;档案长期在自己手里超过2年，也会成为“死档”，本人就属于这种。&lt;/li&gt;
  &lt;li&gt;五年内没有交档案保管费而被人才市场等机构封存的，也会被认为是“死档”。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;七-档案如果不小心成了死档了怎么办不用着急请看办法&quot;&gt;七. 档案如果不小心成了死档了怎么办？不用着急，请看办法！&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;毕业生择业期为两年，如档案遗失，造成没有按规定办理存档手续而成为“死档”，毕业后未超过2年择业期的（有的地方是3年择业期），可直接去人才市场补办存档手续。超过了择业期，则可以按照非普通高等院校毕业生身份，携带身份证. 学历证. 户口簿等材料重新办理存档！但前提是不要超过35岁！&lt;/li&gt;
  &lt;li&gt;把档案留在人才服务机构超过5年没有理会的，只需要补齐代管费. 办妥相关手续，就可将档案关系理顺。&lt;/li&gt;
  &lt;li&gt;自己携带档案要尽快向人才服务机构咨询，如果档案袋被打开，里面的资料需要经过相关部门核实，如果档案资料遗失，还要到原单位去补充和确认&lt;/li&gt;
  &lt;li&gt;“跳槽”人员将档案遗留在原单位长期未办理转档手续的，要与原单位协商，解决跳槽后的遗留问题，以便及时将档案转交。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;最后：郑重提醒：&lt;/p&gt;

&lt;p&gt;师弟师妹们，在这个除了父母兄弟朋友谁也不会管你事情的社会，如果你觉得这篇文章有用，请记得转发给你的朋友或同学。让他们也能和你一样，N年后也省去档案的烦恼。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/isanthree/blog-gallery/pic/image-20210519110517468.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>stepbystep</name></author><category term="生活" /><summary type="html">快毕业了，最近被档案这事搞得有点烦，班群里面发了一个word，关于档案，为了防止不小心删了，也为了更好找到，就搬到这里来了。</summary></entry><entry><title type="html">为windows配置GNU make环境</title><link href="https://isanthree.github.io/2021/05/18/install-make-for-windows/" rel="alternate" type="text/html" title="为windows配置GNU make环境" /><published>2021-05-18T00:00:00+08:00</published><updated>2021-05-18T00:00:00+08:00</updated><id>https://isanthree.github.io/2021/05/18/install-make-for-windows</id><content type="html" xml:base="https://isanthree.github.io/2021/05/18/install-make-for-windows/">&lt;p&gt;一、在windows环境下使用make命令出现下面的错误：&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;make : 无法将“make”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。
所在位置 行:1 字符: 1
+ make
+ ~~~~
    + CategoryInfo          : ObjectNotFound: &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;make:String&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt;, CommandNotFoundException
    + FullyQualifiedErrorId : CommandNotFoundException
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;二、原因分析：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;未安装 make for windows；&lt;/li&gt;
  &lt;li&gt;未正确配置环境变量;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;三、解决办法：安装make for windows&lt;/p&gt;

&lt;p&gt;下载路径：&lt;a href=&quot;http://gnuwin32.sourceforge.net/packages/make.htm&quot;&gt;Make for windows官网&lt;/a&gt; or &lt;a href=&quot;https://wwa.lanzoui.com/i7XwOp8id3c&quot;&gt;蓝奏云&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;官网下载，则选择Complete package, except sources版本，下载并安装&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;四、添加环境变量：（我的环境为 D:\Program Files (x86)\GnuWin32\bin）&lt;/p&gt;

&lt;p&gt;右键我的电脑-&amp;gt;属性-&amp;gt;高级系统设置-&amp;gt;高级-&amp;gt;环境变量-&amp;gt;系统变量-&amp;gt;path&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.loli.net/2021/05/18/YcGlznhVuNDts12.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/isanthree/blog-gallery/pic/20210518140915.pn&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>stepbystep</name></author><category term="环境配置" /><summary type="html">一、在windows环境下使用make命令出现下面的错误：</summary></entry><entry><title type="html">【vscode】intellisense 模式 msvc-x64 与编译器路径不兼容</title><link href="https://isanthree.github.io/2021/05/16/solve-vscode-problem/" rel="alternate" type="text/html" title="【vscode】intellisense 模式 msvc-x64 与编译器路径不兼容" /><published>2021-05-16T00:00:00+08:00</published><updated>2021-05-16T00:00:00+08:00</updated><id>https://isanthree.github.io/2021/05/16/solve-vscode-problem</id><content type="html" xml:base="https://isanthree.github.io/2021/05/16/solve-vscode-problem/">&lt;p&gt;看一下问题：intellisense 模式 msvc-x64 与编译器路径不兼容。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/isanthree/blog-gallery/20210516000401.png&quot; alt=&quot;image-20210516000345240&quot; /&gt;&lt;/p&gt;

&lt;p&gt;接下来看一下解决办法：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/isanthree/blog-gallery/20210516000500.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;我们只需要将此处的 msvc 改为 gcc 即可：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://cdn.jsdelivr.net/gh/isanthree/blog-gallery/20210516000641.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>stepbystep</name></author><category term="环境配置" /><category term="vscode" /><summary type="html">看一下问题：intellisense 模式 msvc-x64 与编译器路径不兼容。</summary></entry><entry><title type="html">我所理解的生活</title><link href="https://isanthree.github.io/2021/05/15/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E7%94%9F%E6%B4%BB/" rel="alternate" type="text/html" title="我所理解的生活" /><published>2021-05-15T00:00:00+08:00</published><updated>2021-05-15T00:00:00+08:00</updated><id>https://isanthree.github.io/2021/05/15/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E7%94%9F%E6%B4%BB</id><content type="html" xml:base="https://isanthree.github.io/2021/05/15/%E6%88%91%E6%89%80%E7%90%86%E8%A7%A3%E7%9A%84%E7%94%9F%E6%B4%BB/">&lt;p&gt;每一次「嘴笨」的背后，都有平时疏于思考的懒惰。——写在最前面。&lt;/p&gt;

&lt;h3 id=&quot;现状&quot;&gt;现状&lt;/h3&gt;

&lt;p&gt;大学准备毕业，迫不及待地想拥有一切。我们一直在匆忙前行，其实最急迫的可能不是快点往前走，而是偶尔停下来想一想为何这样，调整好前进的方向。&lt;/p&gt;

&lt;h3 id=&quot;关于忙&quot;&gt;关于忙&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;所有生活的美学旨在抵抗一个字——忙。忙就是心灵死亡，不要再忙了——你就开始有生活的美学。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;其实细想，忙倒也不可怕，年轻人总得要先折腾一番。可怕的是不知所谓的忙，这通常是没有明确的目的，却把自己置于一刻不得闲的境地，绵绵无绝期，但又仿佛一停下来，就会落于人后，就会在那消停的一段时间里，丢失了生活的意义。&lt;/p&gt;

&lt;h3 id=&quot;关于爱情&quot;&gt;关于爱情&lt;/h3&gt;

&lt;p&gt;在面对「为什么要见面？拒绝‘爱你’‘想你’这样的矫情答案。」这样一个棘手的问题的时候，脑子里似乎有无数个答案试图冲出来但却被贴上矫情标签一一打回。&lt;/p&gt;

&lt;p&gt;爱情也许是这世上最难具象化的东西了吧，不知道近期推出的各种有诚意的聊天工具能不能帮助到被此困扰的思考者们（此处当然是玩笑）。&lt;/p&gt;

&lt;p&gt;试着从网友的智慧里找到一个答案：因为成熟的爱情里的两个人会懂得相处的时候彼此相容，相离的时候彼此相思，相守的时候彼此相依。至于爱情是什么，爱情就是两个人互相的征服，彼此一定要有最与众不同的一点让对方喜欢，比你还要清楚你身上的每一个缺点，当然，更爱你的优点，不会不顾一切对你好，但是你会是我在生命里付出最多的人。&lt;/p&gt;

&lt;p&gt;哈哈哈哈好矫情的回答笑 Crying。&lt;/p&gt;

&lt;p&gt;一个人的时候其实是很无畏很能凑合的，但是爱是会让人懂得害怕的，害怕失去，害怕自己不够好，太多害怕……&lt;/p&gt;

&lt;p&gt;两个人免不了要彼此包容，想要在所有事情上都观点相同是不现实的；两个人应该也要能彼此成就，能有一些促进对方做更好的自己的特质。&lt;/p&gt;

&lt;p&gt;当然最重要的，我们首先还是自己的自己，然后才会是彼此的彼此，每个人都应该活出一个丰满充实的人生，不应把自己的愉悦与幸福过度地寄托在别人身上，幸福是自己感觉出来的。&lt;/p&gt;

&lt;p&gt;任何事情说得太多了就廉价了，比如说爱，比如表白，或许现状才是最好的，或许很多都是错误，以致很长的一段时间，让人不敢去想、去回忆、去面对……&lt;/p&gt;

&lt;h3 id=&quot;关于承诺&quot;&gt;关于承诺&lt;/h3&gt;

&lt;p&gt;一直以来都认为爱情里的承诺是一种很苍白的语言。双方足够信任的时候，不需要承诺，因为会笃定地相信两个人会为了共同的目标去努力。在不得不需要承诺来令对方相信的时候，相信两个人心里都会有一丝悲情和哀伤。&lt;/p&gt;

&lt;p&gt;如果必须要承诺，我承诺我会持续不断地努力让自己和爱的人生活得更好。&lt;/p&gt;

&lt;h3 id=&quot;关于欲望&quot;&gt;关于欲望&lt;/h3&gt;

&lt;p&gt;欲望是无止境的，很多东西，够用舒适就行，在这样的前提下，容易满足的人更容易得到更多的幸福感吧。&lt;/p&gt;

&lt;h3 id=&quot;the-end&quot;&gt;The end&lt;/h3&gt;

&lt;p&gt;最后，以例行的励志高昂充满希望句式结束这一通感慨（网摘）：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;酸甜苦辣咸涩&lt;br /&gt;
都可以&lt;br /&gt;
唯独那无味的&lt;br /&gt;
才最叫人感到失落&lt;br /&gt;
赤橙黄绿青蓝紫&lt;br /&gt;
都行&lt;br /&gt;
唯独那无色的&lt;br /&gt;
才最叫人感到暗淡&lt;br /&gt;
喜怒哀乐哭笑&lt;br /&gt;
都是歌&lt;br /&gt;
唯独那无表情的&lt;br /&gt;
才最叫人悲哀&lt;br /&gt;
生活不能淡而无味&lt;br /&gt;
生命不能黯然无光&lt;br /&gt;
人生应当有所作为&lt;br /&gt;
红红火火&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>stepbystep</name></author><category term="生活" /><category term="随笔" /><summary type="html">每一次「嘴笨」的背后，都有平时疏于思考的懒惰。——写在最前面。</summary></entry></feed>