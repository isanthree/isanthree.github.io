# 算法

滑动窗口的思想：用 i, j 表示滑动窗口的左边界和右边界，通过改变 i, j 来扩展和收缩滑动窗口，可以想象成一个窗口在字符串上游走，当这个窗口包含的元素满足条件，即包含字符串 T 的所有元素，记录下这个滑动窗口的长度 j-i+1，这些长度中的最小值就是要求的结果。

步骤一：不断增加 j 使滑动窗口增大，直到窗口包含了T的所有元素

步骤二: 不断增加 i 使滑动窗口缩小，因为是要求最小字串，所以将不必要的元素排除在外，使长度减小，直到碰到一个必须包含的元素，这个时候不能再扔了，再扔就不满足条件了，记录此时滑动窗口的长度，并保存最小值

步骤三：让 i 再增加一个位置，这个时候滑动窗口肯定不满足条件了，那么继续从步骤一开始执行，寻找新的满足条件的滑动窗口，如此反复，直到 j 超出了字符串 S 范围。

> 面临的问题：
>
> 如何判断滑动窗口包含了 T 的所有元素？
>
> 我们用一个字典 need 来表示当前滑动窗口中需要的各元素的数量，一开始滑动窗口为空，用 T 中各元素来初始化这个 need ，当滑动窗口扩展或者收缩的时候，去维护这个 need 字典，例如当滑动窗口包含某个元素，我们就让 need 中这个元素的数量减 1，代表所需元素减少了 1 个；当滑动窗口移除某个元素，就让 need 中这个元素的数量加 1。
>
> 记住一点：need 始终记录着当前滑动窗口下，我们还需要的元素数量，我们在改变 i,j 时，需同步维护need。
>
> 值得注意的是，只要某个元素包含在滑动窗口中，我们就会在 need 中存储这个元素的数量，如果某个元素存储的是负数代表这个元素是多余的。比如当 need 等于 {'A':-2, 'C':1} 时，表示当前滑动窗口中，我们有2个A是多余的，同时还需要1个C。这么做的目的就是为了步骤二中，排除不必要的元素，数量为负的就是不必要的元素，而数量为 0 表示刚刚好。

回到问题中来，那么如何判断滑动窗口包含了 T 的所有元素？结论就是当 need 中所有元素的数量都小于等于 0 时，表示当前滑动窗口不再需要任何元素。

优化
如果每次判断滑动窗口是否包含了 T 的所有元素，都去遍历 need 看是否所有元素数量都小于等于 0，这个会耗费 O(k) 的时间复杂度，k 代表字典长度，最坏情况下，k 可能等于 len(S)。

其实这个是可以避免的，我们可以维护一个额外的变量 needCount 来记录所需元素的总数量，当我们碰到一个所需元素 c，不仅 need[c] 的数量减少 1，同时 needCount 也要减少 1，这样我们通过 needCount 就可以知道是否满足条件，而无需遍历字典了。
前面也提到过，need 记录了遍历到的所有元素，而只有 need[c]>0 时，代表 c 就是所需元素。

# 图示

以 `S="DOABECODEBANC"`，`T="ABC"` 为例

初始状态：



# code

```cpp
class Solution {
public:
    string minWindow(string s, string t) {
        vector<int> need(256, 0);  // 长度为256，初始值为0的数组
        for(char ch : t) {
            need[ch]++;
        }
        int needCount = t.size();  // 需要满足的字符个数
        int minWindowSize = INT_MAX;  // 最小窗口的长度
        int l = 0, r = 0;
        int start = 0;  // 用于记录窗口的左边界

        while(r < s.size()) {
            if(need[s[r]] > 0) {
                needCount--;
            }
            // 无论这个字符是否包含在t中，need[]数组中对应那个字符的计数都减少1，利用正负区分这个字符匹配的，还是失配的
            need[s[r]]--;
            // 找到了所有的字符
            if(needCount == 0) {
                // 收缩窗口，过滤无关的字符
                while(l < r && need[s[l]] < 0) {
                    need[s[l]]++;  // 刚刚已经将无关字符映射成负的了，现在过滤后，相当于又还回来
                    l++;
                }
                // 过滤完无关字符后的第一个字符，必定为匹配的字符
                if(minWindowSize > r - l + 1) {
                    minWindowSize = r - l + 1;
                    start = l;
                }
                need[s[l]]++;  // 窗口左边界右移的同时，相当于还回去相应的字符
                needCount++;  // 同理，此时需要匹配的数量又还回来一个
                l++;  // 窗口左边界右移
            }
            r++;  // 开启一轮新的循环
        }

        return (minWindowSize == INT_MAX) ? "" : s.substr(start, minWindowSize);
    }
};

```



